[
["index.html", "rgeoda version 0.0.3 1 Introduction 1.1 Live Tutorials 1.2 Open Resources", " rgeoda version 0.0.3 Xun Li 2019-10-17 1 Introduction rgeoda is a R package that wraps all core functions of spatial data analysis in GeoDa and libgeoda. Unlike the desktop software GeoDa, libgeoda is a non-UI and feature focused C++ library that is designed for programmers to do spatial data analysis using their favoriate programming languages (R, Python, Java etc.). It also aims to be easily integratd with other libraries, softwares or systems on different platforms. This book is used to introduce the rgeoda v0.0.3 library, includes all the functions that are currently provided in version 0.0.3. 1.1 Live Tutorials There are some R jupyter notebooks available to replicate all the content of this book: Jupyter Notebooks: https://github.com/lixun910/rgeoda_tutorial/tree/v0.0.3 Note: the second notebook (esda) depends on sp, and the third notebook depends on sf package. You can try these R jupyter notebooks in your browser via MyBinder (no installation required): https://mybinder.org/v2/gh/lixun910/rgeoda_tutorial/v0.0.3 1.2 Open Resources The rgeoda is open-sourced at: https://github.com/lixun910/rgeoda. The libgeoda is open-sourced at: https://github.com/lixun910/libgeoda. If you are interested in python programming, you can try a performance-oriented library rgeoda for spatial data analysis: The rgeoda is open-sourced at: https://github.com/lixun910/rgeoda. If you have any questions or issues, please open a ticket in one of above repositories. Since rgeoda is under active development, this book will be updated frequently. Please “watch” this github repository to get notifications. "],
["intro.html", "2 Installation 2.1 Dependencies 2.2 Mac 2.3 Windows 2.4 Linux 2.5 Load rgeoda library in R", " 2 Installation Like GeoDa desktop software, rgeoda are avaiable to different platforms including: Mac, Linux and Windows. 2.1 Dependencies rgeoda depends on wkb package. Sometimes, the “dependencies=TRUE” argument of install.package() doesn’t guarantee the installation ow wkb automatically. To avoid any potential issues of installation, you can install it first before rgeoda installation: install.packages(&#39;wkb&#39;) 2.2 Mac For Mac users, the “Xcode Command Line Tools” needs to be installed for installing rgeoda. It is a free software provided by Apple, which can be installed by using the following command in a terminal: xcode-select --install In R console, use install.packages() function to install rgeoda from its source pacakge: install.packages(&quot;https://github.com/lixun910/rgeoda/releases/download/0.0.3/rgeoda_0.0.3.tar.gz&quot;) # or the development version # devtools::install_github(&quot;lixun910/rgeoda&quot;) 2.3 Windows In R console, one can use install.packages() function to install rgeoda from its binary pacakge: install.packages(&quot;https://github.com/lixun910/rgeoda/releases/download/0.0.3/rgeoda_0.0.3.zip&quot;) Install rgeoda on windows from source package is not recommended. You would try if you know how to deal with R devtools on windows. 2.4 Linux For Linux users, the “Build Essential Tools” needs to be installed first: sudo apt-get update sudo apt-get install build-essential Then, in R console, use install.packages() function to install rgeoda from its source pacakge: install.packages(&quot;https://github.com/lixun910/rgeoda/releases/download/0.0.3/rgeoda_0.0.3.tar.gz&quot;) # or the development version # devtools::install_github(&quot;lixun910/rgeoda&quot;) 2.5 Load rgeoda library in R If everything installed without error, you should be able to load rgeoda: library(rgeoda) We are working to make rgeoda avaiable in CRAN, so that it could be installed easily (target in 0.1.0 version). "],
["load-spatial-data.html", "3 Load Spatial Data 3.1 Attributes of geoda object 3.2 Access Table Data", " 3 Load Spatial Data The data formats that rgeoda v0.0.3 can load directly includes: ESRI Shapefile MapInfo File CSV GML GPX KML GeoJSON TopoJSON OpenFileGDB GFT Google Fusion Tables CouchDB Note: in this tutorial, we only tested loading ESRI shapefiles using rgeoda v0.0.3. Please create a ticket in rgeoda’s repository if you experience any issues when loading spatial data. For example, to load the ESRI Shapefile Guerry.shp (source: https://geodacenter.github.io/data-and-lab/Guerry/) comes with the package: guerry_path &lt;- system.file(&quot;extdata&quot;, &quot;Guerry.shp&quot;, package = &quot;rgeoda&quot;) guerry &lt;- geoda_open(guerry_path) The geoda_open function returns a geoda object, which can be used to access the meta-data, fields, and columns of the input dataset. Usage geoda_open(ds_path) Arguments ds_path (character) The path of the spatial dataset Value gda_obj An object of geoda class 3.1 Attributes of geoda object n_cols n_obs field_names field_types table (data.frame) To access the meta-data of the loaded Guerry dataset: cat(&quot;\\nnumber of columns:&quot;, guerry$n_cols) ## ## number of columns: 26 cat(&quot;\\nnumber of observations:&quot;, guerry$n_obs) ## ## number of observations: 85 cat(&quot;\\nfield names:&quot;, guerry$field_names) ## ## field names: CODE_DE COUNT AVE_ID_ dept Region Dprtmnt Crm_prs Crm_prp Litercy Donatns Infants Suicids MainCty Wealth Commerc Clergy Crm_prn Infntcd Dntn_cl Lottery Desertn Instrct Prsttts Distanc Area Pop1831 cat(&quot;\\nfield types:&quot;, guerry$field_types) ## ## field types: string numeric numeric integer string string integer integer integer integer integer integer integer integer integer integer integer integer integer integer integer integer integer numeric integer numeric 3.2 Access Table Data The geoda instance has a R data.frame attribute table, which stores the data loaded from the dataset: guerry$table ## CODE_DE COUNT AVE_ID_ dept Region Dprtmnt Crm_prs ## NA 01 1 49 1 E Ain 28870 ## NA.1 02 1 812 2 N Aisne 26226 ## NA.2 03 1 1418 3 C Allier 26747 ## NA.3 04 1 1603 4 E Basses-Alpes 12935 ## NA.4 05 1 1802 5 E Hautes-Alpes 17488 ## NA.5 07 1 2249 7 S Ardeche 9474 ## NA.6 08 1 35395 8 N Ardennes 35203 ## NA.7 09 1 2526 9 S Ariege 6173 ## NA.8 10 1 34410 10 E Aube 19602 ## NA.9 11 1 2807 11 S Aude 15647 ## NA.10 12 1 3369 12 S Aveyron 8236 ## NA.11 13 1 3515 13 S Bouches-du-Rhone 13409 ## NA.12 14 1 3667 14 N Calvados 17577 ## NA.13 15 1 4268 15 C Cantal 18070 ## NA.14 16 1 4527 16 W Charente 24964 ## NA.15 17 1 5205 17 W Charente-Inferieure 18712 ## NA.16 18 1 5417 18 C Cher 21934 ## NA.17 19 1 5942 19 C Correze 15262 ## NA.18 21 1 6174 21 E Cote-d&#39;Or 32256 ## NA.19 22 1 33634 22 W Cotes-du-Nord 28607 ## NA.20 23 1 6735 23 C Creuse 37014 ## NA.21 24 1 7186 24 W Dordogne 21585 ## NA.22 25 1 7482 25 E Doubs 11560 ## NA.23 26 1 8370 26 E Drome 13396 ## NA.24 27 1 8612 27 N Eure 14795 ## NA.25 28 1 9143 28 C Eure-et-Loir 21368 ## NA.26 29 1 9659 29 W Finistere 29872 ## NA.27 30 1 10264 30 S Gard 13115 ## NA.28 31 1 10962 31 S Haute-Garonne 18642 ## NA.29 32 1 11008 32 S Gers 18642 ## NA.30 33 1 11520 33 W Gironde 24096 ## NA.31 34 1 12162 34 S Herault 12814 ## NA.32 35 1 12532 35 W Ille-et-Vilaine 22138 ## NA.33 36 1 12687 36 C Indre 32404 ## NA.34 37 1 13147 37 C Indre-et-Loire 19131 ## NA.35 38 1 13341 38 E Isere 18785 ## NA.36 39 1 13977 39 E Jura 26221 ## NA.37 40 1 14431 40 W Landes 17687 ## NA.38 41 1 14589 41 C Loir-et-Cher 21292 ## NA.39 42 1 15070 42 C Loire 27491 ## NA.40 43 1 15339 43 C Haute-Loire 16170 ## NA.41 44 1 15550 44 W Loire-Inferieure 19314 ## NA.42 45 1 15881 45 C Loiret 17722 ## NA.43 46 1 16029 46 S Lot 5883 ## NA.44 47 1 16326 47 W Lot-et-Garonne 22969 ## NA.45 48 1 16732 48 S Lozere 7710 ## NA.46 49 1 16834 49 W Maine-et-Loire 29692 ## NA.47 50 1 17502 50 N Manche 31078 ## NA.48 51 1 36143 51 N Marne 15602 ## NA.49 52 1 34913 52 E Haute-Marne 26231 ## NA.50 53 1 17708 53 W Mayenne 28331 ## NA.51 54 1 18215 54 E Meurthe 26674 ## NA.52 55 1 18431 55 N Meuse 24507 ## NA.53 56 1 19153 56 W Morbihan 23316 ## NA.54 57 1 19575 57 N Moselle 12153 ## NA.55 58 1 20037 58 C Nievre 25087 ## NA.56 59 1 36521 59 N Nord 26740 ## NA.57 60 1 20823 60 N Oise 28180 ## NA.58 61 1 21456 61 N Orne 28329 ## NA.59 62 1 21990 62 N Pas-de-Calais 23101 ## NA.60 63 1 22829 63 C Puy-de-Dome 17256 ## NA.61 64 1 23572 64 W Basses-Pyrenees 16722 ## NA.62 65 1 24112 65 S Hautes-Pyrenees 12223 ## NA.63 66 1 24280 66 S Pyrenees-Orientales 6728 ## NA.64 67 1 24814 67 E Bas-Rhin 12309 ## NA.65 68 1 24947 68 E Haut-Rhin 7343 ## NA.66 69 1 25381 69 E Rhone 18793 ## NA.67 70 1 26063 70 E Haute-Saone 22339 ## NA.68 71 1 26357 71 E Saone-et-Loire 28391 ## NA.69 72 1 26842 72 C Sarthe 33913 ## NA.70 75 4 31560 75 N Seine 13945 ## NA.71 76 1 28118 76 N Seine-Inferieure 18355 ## NA.72 77 1 28566 77 N Seine-et-Marne 22201 ## NA.73 78 3 31598 78 N Seine-et-Oise 12477 ## NA.74 79 1 29204 79 W Deux-Sevres 18400 ## NA.75 80 1 29360 80 N Somme 33592 ## NA.76 81 1 30128 81 S Tarn 13019 ## NA.77 82 1 30546 82 S Tarn-et-Garonne 14790 ## NA.78 83 1 30753 83 S Var 13145 ## NA.79 84 1 30777 84 S Vaucluse 13576 ## NA.80 85 1 31097 85 W Vendee 20827 ## NA.81 86 1 31387 86 W Vienne 15010 ## NA.82 87 1 31564 87 C Haute-Vienne 16256 ## NA.83 88 1 31810 88 E Vosges 18835 ## NA.84 89 1 32129 89 C Yonne 18006 ## Crm_prp Litercy Donatns Infants Suicids MainCty Wealth Commerc ## NA 15890 37 5098 33120 35039 2 73 58 ## NA.1 5521 51 8901 14572 12831 2 22 10 ## NA.2 7925 13 10973 17044 114121 2 61 66 ## NA.3 7289 46 2733 23018 14238 1 76 49 ## NA.4 8174 69 6962 23076 16171 1 83 65 ## NA.5 10263 27 3188 42117 52547 1 84 1 ## NA.6 8847 67 6400 16106 26198 2 33 4 ## NA.7 9597 18 3542 22916 123625 1 72 60 ## NA.8 4086 59 3608 18642 10989 2 14 3 ## NA.9 10431 34 2582 20225 66498 2 17 35 ## NA.10 6731 31 3211 21981 116671 2 50 70 ## NA.11 5291 38 2314 9325 8107 3 2 26 ## NA.12 4500 52 27830 8983 31807 2 10 48 ## NA.13 11645 31 4093 15335 87338 2 59 7 ## NA.14 13018 36 13602 19454 25720 2 86 47 ## NA.15 5357 39 13254 23999 16798 2 18 5 ## NA.16 10503 13 9561 23574 19497 2 63 56 ## NA.17 12949 12 14993 19330 47480 2 74 80 ## NA.18 9159 60 2540 15599 16128 2 16 12 ## NA.19 7050 16 10387 36098 75056 2 70 86 ## NA.20 20235 23 10997 14363 77823 1 78 82 ## NA.21 10237 18 4687 21375 36024 2 60 72 ## NA.22 5914 73 3436 12512 40690 2 31 57 ## NA.23 7759 42 2829 16348 23816 2 66 41 ## NA.24 4774 51 11712 16039 13493 2 20 17 ## NA.25 4016 54 4553 14475 15015 2 11 21 ## NA.26 6842 15 23945 28392 25143 2 36 84 ## NA.27 7990 40 3048 28726 18292 2 26 31 ## NA.28 7204 31 2286 15378 56140 3 23 40 ## NA.29 10486 38 2848 15250 61510 2 40 30 ## NA.30 7423 40 5076 10676 19220 3 8 20 ## NA.31 10954 45 1680 21346 30869 2 12 34 ## NA.32 6524 25 7686 40736 45180 2 55 77 ## NA.33 7624 17 11315 20046 25014 2 54 55 ## NA.34 6909 27 7254 16601 15272 2 27 25 ## NA.35 8326 29 4077 12236 36275 2 65 46 ## NA.36 8059 73 3012 20384 34476 2 62 54 ## NA.37 6170 28 12059 15302 35375 1 81 68 ## NA.38 6017 27 5626 13364 14417 2 19 23 ## NA.39 12665 29 3446 29605 71364 2 24 79 ## NA.40 18043 21 2746 31017 163241 2 75 85 ## NA.41 9392 24 8310 14097 27289 3 80 76 ## NA.42 5042 42 4753 9986 11813 2 9 24 ## NA.43 9049 24 5194 20383 48783 2 42 67 ## NA.44 8943 31 4432 17681 38501 2 7 53 ## NA.45 5990 27 2040 25157 11092 1 77 69 ## NA.46 8520 23 4410 18708 33358 2 34 52 ## NA.47 7424 43 5179 14281 55564 2 32 73 ## NA.48 4950 63 3963 11267 8334 2 13 6 ## NA.49 9539 72 4013 17507 19586 1 25 7 ## NA.50 9198 19 2107 18544 28331 2 38 75 ## NA.51 6831 68 3912 12355 15652 2 57 11 ## NA.52 9190 74 4196 17333 13463 2 52 2 ## NA.53 7940 14 14739 31754 34196 2 48 81 ## NA.54 4529 57 9515 13877 25572 3 53 19 ## NA.55 8236 20 10452 19747 29381 2 44 33 ## NA.56 6175 45 6092 8926 13851 3 28 38 ## NA.57 6659 54 5501 18021 5994 2 15 14 ## NA.58 8248 45 9242 20852 34069 2 35 62 ## NA.59 4040 49 5740 10575 15400 2 45 39 ## NA.60 12141 19 5963 22948 78148 2 51 78 ## NA.61 8533 47 3299 12393 65995 2 79 71 ## NA.62 9797 53 6001 12125 148039 2 85 51 ## NA.63 7632 31 11644 15167 37843 2 71 37 ## NA.64 4920 62 14472 14356 18623 3 46 16 ## NA.65 4915 71 6001 14783 21233 2 58 29 ## NA.66 4504 45 1983 3910 17003 3 6 18 ## NA.67 7770 59 11701 11850 39714 1 69 27 ## NA.68 10708 32 3710 20442 22184 2 49 61 ## NA.69 8294 30 3357 10779 29280 2 41 45 ## NA.70 1368 71 4204 2660 3632 3 1 9 ## NA.71 2906 43 7245 7506 9523 3 3 22 ## NA.72 5786 54 5303 16324 7315 2 4 13 ## NA.73 3879 56 4007 16303 3460 2 5 8 ## NA.74 6863 41 16956 25461 24533 2 39 59 ## NA.75 7144 44 4964 12447 12836 2 21 36 ## NA.76 6241 20 3449 29305 68980 2 47 44 ## NA.77 8680 25 4558 23771 48317 2 29 50 ## NA.78 9572 23 2449 14800 13380 2 43 39 ## NA.79 5731 37 1246 17239 19024 2 64 28 ## NA.80 7566 28 14035 62486 67963 1 56 64 ## NA.81 4710 25 8922 35224 21851 2 68 43 ## NA.82 6402 13 13817 19940 33497 2 67 63 ## NA.83 9044 62 4040 14978 33029 2 82 42 ## NA.84 6516 47 4276 16616 12789 2 30 15 ## Clergy Crm_prn Infntcd Dntn_cl Lottery Desertn Instrct Prsttts ## NA 11 71 60 69 41 55 46 13 ## NA.1 82 4 82 36 38 82 24 327 ## NA.2 68 46 42 76 66 16 85 34 ## NA.3 5 70 12 37 80 32 29 2 ## NA.4 10 22 23 64 79 35 7 1 ## NA.5 28 76 47 67 70 19 62 1 ## NA.6 50 53 85 49 31 62 9 83 ## NA.7 39 74 28 63 75 22 77 3 ## NA.8 42 77 54 9 28 86 15 207 ## NA.9 15 80 35 27 50 63 48 1 ## NA.10 3 51 5 23 81 10 44 4 ## NA.11 30 45 74 55 3 23 43 25 ## NA.12 7 57 56 11 13 12 22 194 ## NA.13 6 79 83 66 82 1 51 20 ## NA.14 79 2 7 81 60 61 47 8 ## NA.15 86 3 38 72 35 74 42 27 ## NA.16 83 69 11 86 44 51 83 26 ## NA.17 46 86 16 82 84 2 86 3 ## NA.18 37 49 27 18 33 78 13 206 ## NA.19 30 6 69 15 72 47 80 16 ## NA.20 75 75 24 75 85 4 71 12 ## NA.21 77 64 18 79 77 44 78 3 ## NA.22 24 38 25 6 18 73 2 65 ## NA.23 22 21 13 62 54 46 38 8 ## NA.24 27 39 45 45 47 27 23 179 ## NA.25 16 18 62 14 48 72 18 180 ## NA.26 66 24 78 25 36 77 81 42 ## NA.27 81 15 39 59 20 40 40 5 ## NA.28 23 62 59 13 25 15 33 8 ## NA.29 12 43 13 32 74 30 44 1 ## NA.30 69 27 80 48 4 13 41 39 ## NA.31 67 47 51 28 19 43 32 9 ## NA.32 19 12 31 22 37 50 66 77 ## NA.33 84 82 19 83 69 29 79 14 ## NA.34 58 48 3 41 15 49 63 59 ## NA.35 53 52 27 73 23 26 57 12 ## NA.36 32 84 66 43 39 71 3 32 ## NA.37 63 1 43 56 73 28 58 3 ## NA.38 57 65 37 70 46 54 61 54 ## NA.39 34 78 77 34 42 6 56 14 ## NA.40 8 73 17 65 62 3 72 10 ## NA.41 73 56 52 29 12 45 67 63 ## NA.42 54 44 22 16 17 60 37 256 ## NA.43 20 54 15 68 78 24 68 1 ## NA.44 49 26 32 46 52 34 50 5 ## NA.45 2 72 45 42 86 5 60 0 ## NA.46 43 19 36 20 24 76 70 35 ## NA.47 9 33 70 3 59 21 36 98 ## NA.48 47 8 58 39 22 81 10 262 ## NA.49 18 63 55 4 56 65 4 138 ## NA.50 40 59 40 8 61 58 75 46 ## NA.51 26 5 71 1 21 70 8 154 ## NA.52 33 17 65 12 58 59 1 131 ## NA.53 31 9 29 7 32 69 82 38 ## NA.54 13 35 9 2 16 68 16 165 ## NA.55 80 83 20 80 63 37 74 39 ## NA.56 74 14 81 38 7 64 30 308 ## NA.57 60 31 86 50 43 57 20 337 ## NA.58 21 29 50 31 57 25 33 117 ## NA.59 44 36 79 10 27 48 26 163 ## NA.60 52 42 63 61 53 8 76 62 ## NA.61 38 34 72 60 34 7 28 12 ## NA.62 17 85 75 71 76 20 21 5 ## NA.63 4 67 84 77 11 18 52 5 ## NA.64 64 23 48 51 5 53 12 101 ## NA.65 65 40 53 17 10 56 5 26 ## NA.66 35 37 33 21 2 14 31 104 ## NA.67 25 25 68 57 65 83 14 99 ## NA.68 59 11 10 58 45 31 49 40 ## NA.69 41 41 57 19 49 75 35 79 ## NA.70 85 60 67 53 1 33 6 4744 ## NA.71 62 28 61 74 9 36 35 546 ## NA.72 56 16 73 26 29 67 37 453 ## NA.73 45 10 30 24 6 42 17 874 ## NA.74 72 30 4 85 71 84 39 6 ## NA.75 48 7 64 33 30 80 34 302 ## NA.76 14 13 9 47 67 17 73 3 ## NA.77 29 66 41 52 64 39 64 4 ## NA.78 61 55 49 40 26 52 69 6 ## NA.79 78 61 76 54 8 41 45 2 ## NA.80 70 50 44 30 68 79 59 4 ## NA.81 71 20 1 44 40 38 65 18 ## NA.82 76 68 6 78 55 11 84 7 ## NA.83 51 58 34 5 14 85 11 43 ## NA.84 55 32 22 35 51 66 27 272 ## Distanc Area Pop1831 ## NA 218.372 5762 346.03 ## NA.1 65.945 7369 513.00 ## NA.2 161.927 7340 298.26 ## NA.3 351.399 6925 155.90 ## NA.4 320.280 5549 129.10 ## NA.5 279.413 5529 340.73 ## NA.6 105.694 5229 289.62 ## NA.7 385.313 4890 253.12 ## NA.8 83.244 6004 246.36 ## NA.9 370.949 6139 270.13 ## NA.10 296.089 8735 359.06 ## NA.11 362.568 5087 359.47 ## NA.12 117.487 5548 494.70 ## NA.13 245.849 5726 258.59 ## NA.14 224.339 5956 362.53 ## NA.15 238.538 6864 445.25 ## NA.16 116.257 7235 256.06 ## NA.17 227.899 5857 294.83 ## NA.18 136.109 8763 375.88 ## NA.19 225.161 6878 598.87 ## NA.20 180.846 5565 265.38 ## NA.21 253.776 9060 482.75 ## NA.22 202.065 5234 265.54 ## NA.23 295.543 6530 299.56 ## NA.24 61.863 6040 424.25 ## NA.25 54.558 5880 278.82 ## NA.26 276.210 6733 524.40 ## NA.27 323.004 5853 357.38 ## NA.28 361.668 6257 427.86 ## NA.29 343.569 6309 312.16 ## NA.30 291.624 10000 554.23 ## NA.31 344.030 6101 346.30 ## NA.32 179.379 6775 547.05 ## NA.33 139.587 6791 245.29 ## NA.34 126.468 6127 297.02 ## NA.35 268.661 7431 550.26 ## NA.36 197.155 4999 312.50 ## NA.37 344.676 9243 281.50 ## NA.38 90.735 6343 235.75 ## NA.39 215.598 4781 391.22 ## NA.40 248.877 4977 292.08 ## NA.41 199.167 6815 470.09 ## NA.42 61.106 6775 305.28 ## NA.43 275.725 5217 283.83 ## NA.44 302.345 5361 346.89 ## NA.45 283.810 5167 140.35 ## NA.46 157.437 7166 467.87 ## NA.47 157.187 5938 591.28 ## NA.48 77.364 6211 337.08 ## NA.49 129.765 8162 249.83 ## NA.50 139.999 5175 352.59 ## NA.51 159.648 5241 415.57 ## NA.52 126.378 6216 314.59 ## NA.53 230.531 6823 433.52 ## NA.54 180.462 6216 417.00 ## NA.55 119.718 6817 282.52 ## NA.56 106.335 5743 989.94 ## NA.57 33.768 5860 397.73 ## NA.58 97.554 6103 441.88 ## NA.59 104.400 6671 655.22 ## NA.60 205.218 7970 573.11 ## NA.61 387.935 7645 428.40 ## NA.62 386.559 4464 233.03 ## NA.63 403.445 4116 157.05 ## NA.64 217.752 4755 540.21 ## NA.65 217.971 3525 424.26 ## NA.66 213.032 3249 434.43 ## NA.67 176.135 5360 338.91 ## NA.68 168.713 8575 523.97 ## NA.69 108.294 6206 457.37 ## NA.70 0.000 762 935.11 ## NA.71 75.658 6278 693.68 ## NA.72 27.647 5915 323.89 ## NA.73 16.888 5334 448.18 ## NA.74 188.474 5999 297.85 ## NA.75 69.520 6170 543.70 ## NA.76 328.146 5758 333.84 ## NA.77 313.090 3718 242.51 ## NA.78 389.512 5973 317.50 ## NA.79 337.215 3567 239.11 ## NA.80 212.459 6720 330.36 ## NA.81 170.523 6990 282.73 ## NA.82 198.874 5520 285.13 ## NA.83 174.477 5874 397.99 ## NA.84 81.797 7427 352.49 With the table attribute, we can, for example, get the values of “Crm_prp” column: crm_prp &lt;- guerry$table$Crm_prp cat(&quot;\\nfirs 10 values of Crm_prp:&quot;, crm_prp[1:10]) ## ## firs 10 values of Crm_prp: 15890 5521 7925 7289 8174 10263 8847 9597 4086 10431 "],
["spatial-weights.html", "4 Spatial Weights 4.1 Queen Contiguity Weights 4.2 Attributes of Weight object 4.3 Rook Contiguity Weights 4.4 Distance Based Weights 4.5 K-Nearest Neighbor Weights 4.6 Kernel Weights", " 4 Spatial Weights Spatial weights are central components in spatial data analysis. The spatial weights represents the possible spatial interaction between observations in space. Like GeoDa desktop software, rgeoda provides a rich variety of methods to create several different types of spatial weights: Contiguity Based Weights: queen_weights(), rook_weights() Distance Based Weights: distance_weights() K-Nearest Neighbor Weights: knn_weights() Kernel Weights: kernel_weights() 4.1 Queen Contiguity Weights To create a Queen contiguity weights, we can call rgeoda’s function queen_weights(gda, order=1, include_lower_order = False, precision_threshold = 0) by passing the GeoDa object guerry we just created: queen_w &lt;- queen_weights(guerry) queen_w ## Reference class object of class &quot;Weight&quot; ## Field &quot;gda_w&quot;: ## An object of class &quot;_p_GeoDaWeight&quot; ## Slot &quot;ref&quot;: ## &lt;pointer: 0x7f992c30fc10&gt; ## ## Field &quot;is_symmetric&quot;: ## [1] TRUE ## Field &quot;sparsity&quot;: ## [1] 0 ## Field &quot;density&quot;: ## [1] 5.813149 ## Field &quot;min_neighbors&quot;: ## [1] 2 ## Field &quot;max_neighbors&quot;: ## [1] 8 ## Field &quot;num_obs&quot;: ## [1] 85 ## Field &quot;mean_neighbors&quot;: ## [1] 4.941176 ## Field &quot;median_neighbors&quot;: ## [1] 5 The function queen_weights() returns an instance of Weight object. One can access the meta data of the spatial weights by accessing the attributes of Weight object: 4.2 Attributes of Weight object weight_type is_symmetric sparsity density min_nbrs max_nbrs mean_nbrs median_nbrs bool HasIsolates() [] GetNeighbors(idx) double SpatialLag(idx, [data]) SaveToFile() We can also access the details of the weights: e.g. list the neighbors of a specified observation, which is very helpful in exploratory spatial data analysis: nbrs &lt;- queen_w$GetNeighbors(0) cat(&quot;\\nNeighbors of 0-st observation are:&quot;, nbrs) ## ## Neighbors of 0-st observation are: 35 36 66 68 We can also compute the spatial lag of a specified observation by passing the values of the selected variable: lag0 &lt;- queen_w$SpatialLag(0, crm_prp) cat(&quot;\\nSpatial lag of 0-st observation is:&quot;, lag0) ## ## Spatial lag of 0-st observation is: 7899.25 4.3 Rook Contiguity Weights To create a Rook contiguity weights, we can call rgeoda’s function rook_weights(gda, order=1,include_lower_order=False, precision_threshold = 0) by passing the geoda object guerry we just created: rook_w &lt;- rook_weights(guerry) rook_w ## Reference class object of class &quot;Weight&quot; ## Field &quot;gda_w&quot;: ## An object of class &quot;_p_GeoDaWeight&quot; ## Slot &quot;ref&quot;: ## &lt;pointer: 0x7f992c0a4720&gt; ## ## Field &quot;is_symmetric&quot;: ## [1] TRUE ## Field &quot;sparsity&quot;: ## [1] 0 ## Field &quot;density&quot;: ## [1] 5.813149 ## Field &quot;min_neighbors&quot;: ## [1] 2 ## Field &quot;max_neighbors&quot;: ## [1] 8 ## Field &quot;num_obs&quot;: ## [1] 85 ## Field &quot;mean_neighbors&quot;: ## [1] 4.941176 ## Field &quot;median_neighbors&quot;: ## [1] 5 The weights we created are in memory, which makes it straight forward for spatial data analysis and also are good for programming your application. To save the weights to a file, we need to call aWeight’s function SaveToFile(ofname, layer_name, id_name, id_vec) The layer_name is the layer name of loaded dataset. For a ESRI shapefile, the layer name is the file name without the suffix (e.g. Guerry). The id_name is a key (column name), which means the associated column contains unique values, that makes sure that the weights are connected to the correct observations in the data table. The id_vec is the actual column data of id_name, it could be a tuple of integer or string values. For example, in Guerry dataset, the column “CODE_DE” can be used as a key to save a weights file: rook_w$SaveToFile(&#39;/Users/xun/Downloads/Guerry_r.gal&#39;, &#39;Guerry&#39;, &#39;CODE_DE&#39;, guerry$GetIntegerCol(&#39;CODE_DE&#39;)) ## [1] TRUE Then, we should find the file “Guerry_r.gal” in the output directory. 4.4 Distance Based Weights To create a Distance based weights, we can call rgeoda’s function distance_weights(gda, dist_thres, power=1.0, is_inverse=False, is_arc=False, is_mile=True) by passing the GeoDa object guerry we just created and the value of distance threshold. Like GeoDa, rgeoda provides a function to help you find a optimized distance threshold that guarantees that every observation has at least one neighbor: min_distthreshold(GeoDa gda, bool is_arc = False, bool is_mile = True) dist_thres &lt;- min_distthreshold(guerry) dist_w &lt;- distance_weights(guerry, dist_thres) dist_w ## Reference class object of class &quot;Weight&quot; ## Field &quot;gda_w&quot;: ## An object of class &quot;_p_GeoDaWeight&quot; ## Slot &quot;ref&quot;: ## &lt;pointer: 0x7f99286b2950&gt; ## ## Field &quot;is_symmetric&quot;: ## [1] FALSE ## Field &quot;sparsity&quot;: ## [1] 0 ## Field &quot;density&quot;: ## [1] 4.346021 ## Field &quot;min_neighbors&quot;: ## [1] 1 ## Field &quot;max_neighbors&quot;: ## [1] 7 ## Field &quot;num_obs&quot;: ## [1] 85 ## Field &quot;mean_neighbors&quot;: ## [1] 3.694118 ## Field &quot;median_neighbors&quot;: ## [1] 4 4.5 K-Nearest Neighbor Weights A special case of distance based weights is K-Nearest neighbor weights, in which every obersvation will have exactly k neighbors. To create a KNN weights, we can call rgeoda’s function: knn_weights(gda, k, power = 1.0,is_inverse = False, is_arc = False, is_mile = True) For example, to create a 6-nearest neighbor weights using Guerry dataset: knn6_w &lt;- knn_weights(guerry, 6) knn6_w ## Reference class object of class &quot;Weight&quot; ## Field &quot;gda_w&quot;: ## An object of class &quot;_p_GeoDaWeight&quot; ## Slot &quot;ref&quot;: ## &lt;pointer: 0x7f99286016b0&gt; ## ## Field &quot;is_symmetric&quot;: ## [1] FALSE ## Field &quot;sparsity&quot;: ## [1] 0 ## Field &quot;density&quot;: ## [1] 7.058824 ## Field &quot;min_neighbors&quot;: ## [1] 6 ## Field &quot;max_neighbors&quot;: ## [1] 6 ## Field &quot;num_obs&quot;: ## [1] 85 ## Field &quot;mean_neighbors&quot;: ## [1] 6 ## Field &quot;median_neighbors&quot;: ## [1] 6 4.6 Kernel Weights Kernel weights apply kernel function to determine the distance decay in the derived continuous weights kernel. The kernel weights are defined as a function K(z) of the ratio between the distance dij from i to j, and the bandwidth hi, with z=dij/hi. The kernl functions include triangular uniform quadratic epanechnikov quartic gaussian Two functions are provided in rgeoda to create kernel weights: 4.6.1 Kernel Weights with fixed bandwidth To create a kernel weights with fixed bandwith: bandwidth &lt;- min_distthreshold(guerry) kernel_w &lt;- kernel_weights(guerry, bandwidth, &quot;uniform&quot;) kernel_w ## Reference class object of class &quot;Weight&quot; ## Field &quot;gda_w&quot;: ## An object of class &quot;_p_GeoDaWeight&quot; ## Slot &quot;ref&quot;: ## &lt;pointer: 0x7f992c3d9270&gt; ## ## Field &quot;is_symmetric&quot;: ## [1] FALSE ## Field &quot;sparsity&quot;: ## [1] 0 ## Field &quot;density&quot;: ## [1] 4.346021 ## Field &quot;min_neighbors&quot;: ## [1] 1 ## Field &quot;max_neighbors&quot;: ## [1] 7 ## Field &quot;num_obs&quot;: ## [1] 85 ## Field &quot;mean_neighbors&quot;: ## [1] 3.694118 ## Field &quot;median_neighbors&quot;: ## [1] 4 Besides the options is_inverse, power, is_arc and is_mile that are the same with the distance based weights, this kernel weights function has another option: use_kernel_diagonals (optional) FALSE (default) or TRUE, apply kernel on the diagonal of weights matrix 4.6.2 Kernel Weights with adaptive bandwidth To create a kernel weights with adaptive bandwidth or using max KNN distance as bandwidth: adptkernel_w &lt;- kernel_knn_weights(guerry, 6, &quot;uniform&quot;) adptkernel_w ## Reference class object of class &quot;Weight&quot; ## Field &quot;gda_w&quot;: ## An object of class &quot;_p_GeoDaWeight&quot; ## Slot &quot;ref&quot;: ## &lt;pointer: 0x7f992c38cc30&gt; ## ## Field &quot;is_symmetric&quot;: ## [1] FALSE ## Field &quot;sparsity&quot;: ## [1] 0 ## Field &quot;density&quot;: ## [1] 7.058824 ## Field &quot;min_neighbors&quot;: ## [1] 6 ## Field &quot;max_neighbors&quot;: ## [1] 6 ## Field &quot;num_obs&quot;: ## [1] 85 ## Field &quot;mean_neighbors&quot;: ## [1] 6 ## Field &quot;median_neighbors&quot;: ## [1] 6 This kernel weights function two more options: adaptive_bandwidth (optional) TRUE (default) or FALSE: TRUE use adaptive bandwidth calculated using distance of k-nearest neithbors, FALSE use max distance of all observation to their k-nearest neighbors use_kernel_diagonals (optional) FALSE (default) or TRUE, apply kernel on the diagonal of weights matrix "],
["spatial-autocorrelation.html", "5 Spatial Autocorrelation 5.1 Local Moran 5.2 LISA object 5.3 Local Geary 5.4 Local Getis-Ord Statistics 5.5 Local Join Count", " 5 Spatial Autocorrelation rgeoda 0.0.3 provids following methods for univariate local spatial autocorrelation statistics: Local Moran: local_moran() Local Geary: local_geary() Local Getis-Ord statistics: local_g() and local_gstar() Local Join Count: local_joincount() Methods for bivariate and multivariate local spatial autocorrelation statistics, as well as global spatial autocorrelation satatistics, will be included in next release of rgeoda. In this tutorial, we will only introduce how to call these methods using rgeoda. For more information about the local spatial autocorrelation statisticis, please read the lab note that Dr. Luc Anselin wrote: http://geodacenter.github.io/workbook/6a_local_auto/lab6a.html. 5.1 Local Moran The Local Moran statistic is a method to identify local clusters and local spatial outliers. For example, we can call function local_moran() with the created Queen weights and the data “crm_prp” as input parameters: lisa &lt;- local_moran(queen_w, crm_prp) 5.2 LISA object The local_moran() function will return a lisa object, which we can call its functions to access the results of lisa computation. The functions include: GetClusterIndicators() ---------------------- Get the local cluster indicators returned from LISA computation. GetColors() ----------- Get the cluster colors of LISA computation. GetLabels() ----------- Get the cluster labels of LISA computation. GetLISAValues() --------------- Get the local spatial autocorrelation values returned from LISA computation. GetNumNeighbors() ----------------- Get the number of neighbors of every observations in LISA computation. GetPValues() ------------ Get the local pseudo-p values of significance returned from LISA computation. SetPermutations(num_perm) ------------------------- Set the number of permutations for the LISA computation SetThreads(num_threads) ----------------------- Set the number of CPU threads for the LISA computation Run() ----- Call to run LISA computation For example, we can call the function GetLISAValues() to get the values of local Moran: lms &lt;- lisa$GetLISAValues() lms ## [1] 0.0154319783 0.3270633224 0.0212952962 0.0046105448 -0.0028342407 ## [6] 0.4149377158 -0.1379463091 0.0998657692 0.2823176310 0.1218745112 ## [11] -0.0951205417 0.0326111938 0.3878324535 1.1888723840 -0.6452792226 ## [16] -0.3096492740 0.3662775143 2.0375343539 -0.0050154800 0.0697110572 ## [21] 2.2720355722 0.2886391551 -0.0070189726 -0.0009906605 0.9517469793 ## [26] 0.7648322095 0.0432039929 -0.0045362842 -0.0964911860 0.0952360887 ## [31] 0.0100895206 -0.0109401003 -0.0544245927 -0.0345553975 0.0887531916 ## [36] 0.0954232056 0.0383617454 -0.1776714441 0.1638208393 1.2309154898 ## [41] 2.9077203402 -0.0396340261 0.4458735227 0.2491123240 0.0905643622 ## [46] -0.6212977834 -0.0308773407 0.0375870399 0.2270376112 -0.0918254739 ## [51] -0.0112400086 0.1085584763 -0.0055113129 -0.0027097589 0.7235016208 ## [56] 0.0163129939 0.4246564560 0.3787307767 -0.0597158189 0.5050011802 ## [61] 2.7632125275 0.0656510809 0.1771899330 -0.0572150317 0.4943795537 ## [66] 0.2870386197 -1.4593300774 -0.0055305930 0.4895990016 -0.0324125662 ## [71] 2.1366499813 0.9041683235 0.7053678641 1.4098290925 0.0051652159 ## [76] 0.2238144189 -0.1621373954 0.0195632289 -0.3233724187 -0.0337778226 ## [81] 0.0118189869 -0.1164679533 -0.5699624657 -0.0859634996 0.2085373916 To get the pseudo-p values of significance of local Moran computation: pvals &lt;- lisa$GetPValues() pvals ## [1] 0.414 0.123 0.001 0.474 0.452 0.087 0.243 0.326 0.299 0.303 0.237 ## [12] 0.460 0.258 0.018 0.199 0.188 0.131 0.004 0.456 0.342 0.041 0.143 ## [23] 0.429 0.412 0.002 0.026 0.480 0.400 0.121 0.350 0.481 0.441 0.338 ## [34] 0.120 0.267 0.050 0.072 0.221 0.282 0.022 0.029 0.494 0.075 0.054 ## [45] 0.200 0.025 0.359 0.346 0.280 0.375 0.487 0.267 0.441 0.428 0.135 ## [56] 0.314 0.050 0.002 0.085 0.297 0.001 0.233 0.243 0.134 0.116 0.342 ## [67] 0.015 0.334 0.069 0.303 0.040 0.132 0.001 0.002 0.470 0.007 0.213 ## [78] 0.387 0.123 0.403 0.455 0.352 0.011 0.322 0.135 To get the cluster indicators of local Moran computation: cats &lt;- lisa$GetClusterIndicators() cats ## [1] 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 0 0 2 2 0 0 0 0 0 0 0 0 0 ## [36] 1 0 0 0 1 1 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 2 2 0 0 1 0 0 0 0 0 3 0 0 0 ## [71] 2 0 2 2 0 2 0 0 0 0 0 0 3 0 0 The predefined values of the indicators of LISA cluster are: 0 Not significant 1 High-High 2 Low-Low 3 High-Low 4 Low-High 5 Neighborless 6 Undefined which can be accessed via function GetLabels(): lbls &lt;- lisa$GetLabels() lbls ## [1] &quot;Not significant&quot; &quot;High-High&quot; &quot;Low-Low&quot; &quot;High-Low&quot; ## [5] &quot;Low-High&quot; &quot;Undefined&quot; &quot;Isolated&quot; Different LISA objects (e.g. local_geary()) will return different labels and colors. By default, the local_moran() function will run with some default parameters, e.g.: permutation number: 999 seed for random number generator: 123456789 , which are identical to GeoDa desktop software so that we can replicate the results in GeoDa software. It is also easy to change the paremter and re-run the LISA computation by calling Run() function. For example, re-run the above local Moran example using 9999 permutations lisa$SetPermutations(9999) ## NULL lisa$Run() ## NULL Then, we can use the same lisa object to get the new results after 9999 permutations: pvals &lt;- lisa$GetPValues() pvals ## [1] 0.4187 0.1265 0.0004 0.4679 0.4545 0.0728 0.2312 0.3071 0.3115 0.3088 ## [11] 0.2187 0.4803 0.2623 0.0113 0.2000 0.1797 0.1267 0.0026 0.4565 0.3517 ## [21] 0.0450 0.1367 0.4344 0.4231 0.0024 0.0366 0.4741 0.4164 0.1293 0.3310 ## [31] 0.4893 0.4371 0.3350 0.1376 0.2723 0.0567 0.0753 0.2221 0.2559 0.0192 ## [41] 0.0216 0.4918 0.0739 0.0564 0.2193 0.0199 0.3667 0.3339 0.2764 0.3783 ## [51] 0.4679 0.2683 0.4495 0.4312 0.1423 0.3158 0.0612 0.0009 0.0900 0.2861 ## [61] 0.0001 0.2378 0.2518 0.1295 0.1262 0.3482 0.0105 0.3152 0.0692 0.2984 ## [71] 0.0260 0.1331 0.0001 0.0001 0.4683 0.0067 0.2197 0.3718 0.1392 0.4054 ## [81] 0.4420 0.3462 0.0039 0.3136 0.1288 rgeoda uses GeoDa’s C++ code, in which multi-threading is used to accelerate the computation of LISA. We can specify how many threads to run the computation: lisa$SetThreads(4) ## NULL lisa$Run() ## NULL lisa$GetPValues() ## [1] 0.4187 0.1265 0.0004 0.4679 0.4545 0.0728 0.2312 0.3071 0.3115 0.3088 ## [11] 0.2187 0.4834 0.2686 0.0102 0.2024 0.1795 0.1218 0.0025 0.4590 0.3588 ## [21] 0.0476 0.1456 0.4344 0.4231 0.0024 0.0366 0.4741 0.4164 0.1293 0.3310 ## [31] 0.4893 0.4371 0.3350 0.1424 0.2751 0.0564 0.0713 0.2202 0.2672 0.0186 ## [41] 0.0214 0.4960 0.0721 0.0589 0.2288 0.0189 0.3759 0.3217 0.2812 0.3735 ## [51] 0.4695 0.2743 0.4518 0.4286 0.1471 0.3222 0.0647 0.0016 0.0955 0.2840 ## [61] 0.0001 0.2388 0.2465 0.1242 0.1275 0.3493 0.0120 0.3158 0.0719 0.2979 ## [71] 0.0291 0.1386 0.0001 0.0003 0.4627 0.0058 0.2168 0.3761 0.1386 0.4119 ## [81] 0.4631 0.3421 0.0045 0.3138 0.1257 5.3 Local Geary Local Geary is a type of LISA that focuses on squared differences/dissimilarity. A small value of the local geary statistics suggest positive spatial autocorrelation, whereas large values suggest negative spatial autocorrelation. For example, we can call the function local_geary() with the created Queen weights and the data “crm_prp” as input parameters: geary_crmprp &lt;- local_geary(queen_w, crm_prp) To get the cluster indicators of the local Geary computation: geary_crmprp$GetClusterIndicators() ## [1] 0 2 4 0 3 0 0 0 0 0 0 0 0 0 0 0 0 1 0 2 1 0 0 0 2 2 0 0 0 0 0 0 0 4 0 ## [36] 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [71] 2 0 0 2 0 0 0 0 0 0 0 0 4 0 0 To get the pseudo-p values of the local Geary computation: geary_crmprp$GetPValues() ## [1] 0.398 0.027 0.025 0.126 0.017 0.314 0.610 0.141 0.284 0.110 0.559 ## [12] 0.462 0.211 0.236 0.249 0.229 0.069 0.041 0.205 0.020 0.029 0.178 ## [23] 0.369 0.112 0.024 0.027 0.092 0.420 0.488 0.051 0.377 0.253 0.217 ## [34] 0.049 0.110 0.151 0.147 0.584 0.327 0.107 0.009 0.129 0.135 0.190 ## [45] 0.031 0.086 0.084 0.292 0.299 0.418 0.053 0.431 0.178 0.077 0.092 ## [56] 0.294 0.116 0.321 0.573 0.204 0.196 0.264 0.084 0.616 0.131 0.408 ## [67] 0.058 0.088 0.282 0.264 0.040 0.085 0.059 0.002 0.711 0.543 0.620 ## [78] 0.057 0.335 0.411 0.197 0.625 0.010 0.364 0.265 5.4 Local Getis-Ord Statistics There are two types of local Getis-Ord statistics: one is computing a ratio of the weighted average of the values in the neighboring locations, not including the value at the location; while another type of statistic includes the value at the location in both numerator and denominator. A value larger than the mean suggests a high-high cluster or hot spot, a value smaller than the mean indicates a low-low cluster or cold spot. For example, we can call the function local_g() with the created Queen weights and the data “crm_prp” as input parameters: localg_crmprp &lt;- local_g(queen_w, crm_prp) To get the cluster indicators of the local G computation: localg_crmprp$GetClusterIndicators() ## [1] 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 0 0 2 2 0 0 0 0 0 0 0 0 0 ## [36] 1 0 0 0 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 2 2 0 0 1 0 0 0 0 0 1 0 0 0 ## [71] 2 0 2 2 0 2 0 0 0 0 0 0 1 0 0 To get the pseudo-p values of the local G computation: localg_crmprp$GetPValues() ## [1] 0.414 0.123 0.001 0.474 0.452 0.087 0.243 0.326 0.299 0.303 0.237 ## [12] 0.460 0.258 0.018 0.199 0.188 0.131 0.004 0.456 0.342 0.041 0.143 ## [23] 0.429 0.412 0.002 0.026 0.479 0.400 0.121 0.350 0.481 0.441 0.338 ## [34] 0.120 0.266 0.050 0.072 0.221 0.282 0.022 0.029 0.494 0.075 0.054 ## [45] 0.200 0.025 0.359 0.346 0.280 0.375 0.487 0.266 0.441 0.428 0.135 ## [56] 0.314 0.050 0.002 0.085 0.297 0.001 0.233 0.243 0.134 0.116 0.340 ## [67] 0.015 0.334 0.069 0.303 0.039 0.132 0.001 0.002 0.470 0.007 0.213 ## [78] 0.387 0.123 0.403 0.455 0.352 0.011 0.322 0.135 For the second type of local Getis-Ord statistics, we can call the function local_gstar() with the created Queen weights and the data “crm_prp” as input parameters: localgstar_crmprp &lt;- local_gstar(queen_w, crm_prp) 5.5 Local Join Count Local Join Count is a method to identify local clusters for binary data by using a local version of the so-called BB join count statistic. The statistic is only meaningful for those observations with value 1. For example, we can load the columbus dataset, and call the function local_joincount() with a Queen weights and the data “nsa”, which is a set of binary (0,1) values, as input parameters: columbus_path &lt;- system.file(&quot;extdata&quot;, &quot;columbus.shp&quot;, package = &quot;rgeoda&quot;) columbus &lt;- geoda_open(columbus_path) columbus_w &lt;- queen_weights(columbus) localjc_crmprp &lt;- local_joincount(columbus_w, columbus$table$nsa) To get the cluster indicators of the local Join Count computation: localjc_crmprp$GetClusterIndicators() ## [1] 0 0 1 1 1 0 1 1 1 0 1 1 1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [36] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 To get the pseudo-p values of the local Join Count computation: localjc_crmprp$GetPValues() ## [1] 0.213 0.070 0.017 0.010 0.001 0.234 0.018 0.007 0.006 0.275 0.017 ## [12] 0.008 0.043 0.004 0.002 0.001 0.147 0.049 0.087 0.001 0.001 0.372 ## [23] 0.001 0.450 0.287 0.249 0.001 0.001 0.001 0.001 0.001 0.001 0.001 ## [34] 0.001 0.001 0.001 0.001 0.001 0.001 0.001 0.001 0.001 0.001 0.001 ## [45] 0.001 0.001 0.001 0.001 0.001 To get the number of neighbors of the local Join Count computation: localjc_crmprp$GetNumNeighbors() ## [1] 2 3 4 5 8 2 5 6 8 4 5 6 4 6 6 8 3 4 3 10 3 6 3 ## [24] 7 8 6 4 9 7 5 3 4 4 4 7 5 6 6 3 5 3 2 6 5 4 2 ## [47] 2 4 3 "],
["spatial-clustering.html", "6 Spatial Clustering 6.1 SKATER 6.2 REDCAP 6.3 Max-p", " 6 Spatial Clustering Spatial clustering aims to group of a large number of geographic areas or points into a smaller number of regions based on similiarities in one or more variables. Spatially constrained clustering is needed when clusters are required to be spatially contiguous. In rgeoda v0.0.3, there are three different approaches explicitly incorporate the contiguity constraint in the optimization process: SKATER, Redcap and Max-p. More more details, please read the lab note that Dr. Luc Anselin wrote: http://geodacenter.github.io/workbook/8_spatial_clusters/lab8.html For example, to apply spatial clustering on the Guerry dataset, we use the queen weights to define the spatial contiguity and select 6 variables for similarity measure: “Crm_prs”, “Crm_prp”, “Litercy”, “Donatns”, “Infants”, “Suicids”. The following code is used to get a 2D data list for the selected variables: data &lt;- list(guerry$table$Crm_prs, guerry$table$Crm_prp, guerry$table$Litercy, guerry$table$Donatns, guerry$table$Infants, guerry$table$Suicids) 6.1 SKATER The Spatial C(K)luster Analysis by Tree Edge Removal(SKATER) algorithm introduced by Assuncao et al. (2006) is based on the optimal pruning of a minimum spanning tree that reflects the contiguity structure among the observations. It provides an optimized algorithm to prune to tree into several clusters that their values of selected variables are as similar as possible. The SKATER function in rgeoda: skater(k, w, data, distance_method=&#39;euclidean&#39;, bound_vals = [], min_bound = 0, random_seed=123456789) The parameters distance_method, bound_vals, min_bound and random_seed are optional. See Max-p for the usage of bound_vals and min_bound. For example, to create 4 spatially contiguous clusters using skater() with Guerry dataset, the queen weights and the values of the 6 selected variables: guerry_clusters &lt;- skater(4, queen_w, data) This skater() function returns a 2D list, which represents 4 clusters. Each cluster is composed by several contiguity areas, e.g. 15, 74, 16, 55, 60, 39, 68, 33, 17, 82, 81, 0, 2, 40, 20, 80 rgeoda also provides utility functions to compute some descriptive statistics of the clustering results, e.g. to compute the ratio of between to total sum of squares: betweenss &lt;- between_sumofsquare(guerry_clusters, data) totalss &lt;- total_sumofsquare( data) ratio &lt;- betweenss / totalss cat(&quot;The ratio of between to total sum of square:&quot;, ratio) ## The ratio of between to total sum of square: 0.3156447 6.2 REDCAP REDCAP (Regionalization with dynamically constrained agglomerative clustering and partitioning) is developed by D. Guo (2008). Like SKATER, REDCAP starts from building a spanning tree with 3 different ways (single-linkage, average-linkage, and the complete-linkage). The single-linkage way leads to build a minimum spanning tree. Then,REDCAP provides 2 different ways (first‐order and full-order constraining) to prune the tree to find clusters. The first-order approach with a minimum spanning tree is exactly the same with SKATER. In GeoDa and rgeoda, the following methods are provided: First-order and Single-linkage Full-order and Complete-linkage Full-order and Average-linkage Full-order and Single-linkage For example, to find 4 clusters using the same dataset and weights as above using REDCAP with Full-order and Complete-linkage method: redcap_clusters &lt;- redcap(4, queen_w, data, &quot;fullorder-completelinkage&quot;) redcap_clusters ## [[1]] ## [1] 15 74 16 55 60 39 68 33 17 82 81 0 2 40 20 80 ## ## [[2]] ## [1] 46 50 34 38 69 47 58 19 32 41 53 26 ## ## [[3]] ## [1] 23 79 3 29 61 21 44 11 28 13 30 35 76 77 43 9 27 45 31 78 4 10 66 ## [24] 37 5 14 7 63 62 ## ## [[4]] ## [1] 49 52 72 84 8 57 56 59 42 1 25 51 48 54 64 75 18 83 73 36 24 71 6 ## [24] 67 65 70 22 12 betweenss &lt;- between_sumofsquare(redcap_clusters, data) totalss &lt;- total_sumofsquare( data) ratio &lt;- betweenss / totalss cat(&quot;The ratio of between to total sum of square:&quot;, ratio) ## The ratio of between to total sum of square: 0.3156447 6.3 Max-p The so-called max-p regions model (outlined in Duque, Anselin, and Rey 2012) uses a different approach and considers the regionalization problem as an application of integer programming. In addition, the number of regions is determined endogenously. The algorithm itself consists of a search process that starts with an initial feasible solution and iteratively improves upon it while maintaining contiguity among the elements of each cluster. Like Geoda, rgeoda provides three different heuristic algorithms to find an optimal solution for max-p: greedy Tabu Search Simulated Annealing Unlike SKATER and REDCAP that one can specify the number of clusters as an input paramter, max-p doesn’t allow to specify the number of clusters explicitly, but a constrained variable and the minimum bounding value that each cluster should reach that are used to find an optimized number of clusters. For example, to use greedy algorithm in maxp function with the same dataset and weights as above to find optimal clusters using max-p: First, we need to specify, for example, every cluster must have population &gt;= 3236.67 thousands people: bound_vals &lt;- guerry$table$Pop1831 min_bound &lt;- 3236.67 # 10% of Pop1831 Then, we can call the max-p function with “greedy” algorith, the bound values and minimum bound value: maxp_clusters &lt;- maxp(queen_w, data, bound_vals, min_bound, &quot;greedy&quot;) betweenss &lt;- between_sumofsquare(maxp_clusters, data) ratio &lt;- betweenss / totalss cat(&quot;The ratio of between to total sum of square:&quot;, ratio) ## The ratio of between to total sum of square: 0.5070181 We can also specify using tabu search algorithm in maxp function with the parameter of tabu length: maxp_tabu_clusters &lt;- maxp(queen_w, data, bound_vals, min_bound, &quot;tabu&quot;, tabu_length=95) betweenss &lt;- between_sumofsquare(maxp_tabu_clusters, data) ratio &lt;- betweenss / totalss cat(&quot;The ratio of between to total sum of square:&quot;, ratio) ## The ratio of between to total sum of square: 0.5280299 To apply simulated annealing algorithm in maxp function with the parameter of cooling rate: maxp_sa_clusters &lt;- maxp(queen_w, data, bound_vals, min_bound, &quot;sa&quot;, cool_rate=0.75) betweenss &lt;- between_sumofsquare(maxp_sa_clusters, data) ratio &lt;- betweenss / totalss cat(&quot;The ratio of between to total sum of square:&quot;, ratio) ## The ratio of between to total sum of square: 0.5260249 We can also increase the number of iterations for local search process by specifying the parameter initial (default value is 99): maxp_clusters &lt;- maxp(queen_w, data, bound_vals, min_bound, &quot;greedy&quot;, initial=1000) betweenss &lt;- between_sumofsquare(maxp_clusters, data) ratio &lt;- betweenss / totalss cat(&quot;Tratio of between to total sum of square:&quot;, ratio) ## Tratio of between to total sum of square: 0.5260249 "],
["esda-with-rgeoda-and-sp.html", "7 ESDA with rgeoda and sp 7.1 Start from sp package 7.2 Create geoda object from sp 7.3 ESDA with rgeoda and sp", " 7 ESDA with rgeoda and sp For people who using R to do spatial data analysis, a common routine is to use rgdal package to read spatial dataset, and then use sp package, or (in recent) sf package, to handle and analyze spatial data and plot the results on maps. rgeoda provides utility functions to create a geoda instance from an sp object or sf object, so that users can easily integrate the functions of spatial data analysis in rgeoda into their existing work. In this note, we will work with sp and rgeoda package to do exploratory spatial data analysis (ESDA). 7.1 Start from sp package The sp package has been an essential tool which provides spatial data-structures and many utility functions to do spatial analysis in R. It has been a core dependent library for many other packages, e.g. rgdal (IO), maptools (mapping), spdep (spatial weights, spatial statistics, and spatial models) etc. Using rgdal to read a ESRI Shapefile will return a sp (Spatial object) object, which could be either a SpatialPointsDataFrame (using an AttributeList for its data slot directly), a SpatialLinesDataFrame, or a SpatialPolygonsDataFrame. # use the Guerry.shp comes with the rgeoda package guerry_path &lt;- system.file(&quot;extdata&quot;, &quot;Guerry.shp&quot;, package = &quot;rgeoda&quot;) # load rgdal library which sp is working with library(rgdal) ## Loading required package: sp ## rgdal: version: 1.4-4, (SVN revision 833) ## Geospatial Data Abstraction Library extensions to R successfully loaded ## Loaded GDAL runtime: GDAL 2.4.1, released 2019/03/15 ## Path to GDAL shared files: /usr/local/Cellar/gdal/2.4.1_1/share/gdal ## GDAL binary built with GEOS: TRUE ## Loaded PROJ.4 runtime: Rel. 6.1.0, May 15th, 2019, [PJ_VERSION: 610] ## Path to PROJ.4 shared files: (autodetected) ## Linking to sp version: 1.3-1 Note: to install rgdal library in R, you can run: install.packages(‘rgdal’) Then, we can call readOGR() function to read Guerry.shp file and this function will returns an sp object guerry_sp &lt;- readOGR(guerry_path) ## OGR data source with driver: ESRI Shapefile ## Source: &quot;/usr/local/lib/R/3.6/site-library/rgeoda/extdata/Guerry.shp&quot;, layer: &quot;Guerry&quot; ## with 85 features ## It has 26 fields ## Integer64 fields read as strings: dept Crm_prs Crm_prp Litercy Donatns Infants Suicids MainCty Wealth Commerc Clergy Crm_prn Infntcd Dntn_cl Lottery Desertn Instrct Prsttts Area You can simply call plot() function to plot this map: plot(guerry_sp) 7.2 Create geoda object from sp Everything above should be very familiar with you, right? Then, the fun part of spatial data analysis is going to start: Create a geoda object from the sp object guerry_sp you just created. library(rgeoda) guerry &lt;- sp_to_geoda(guerry_sp) ## Loading required package: wkb That’s it! It should be very fast: rgeoda uses wkb, which is a binary representation of geometries, to exchange data between sp and rgeoda in memory. By default, sp_to_geoda() only using geometries to create a geoda object, which is fast and user can reuse the data.frame from the sp object to do analysis. This function has an optional parameter with_table, to allow user to use both geometries and data.frame to create a geoda object by calling, for example: sp_to_geoda(guerry_sp, with_table=TRUE) 7.3 ESDA with rgeoda and sp Now, with the geoda object guerry, you can call rgeoda’s spatial analysis functions. For example, to examine the local Moran statistics of variable “crm_prp” (Population per Crime against persons): queen_w &lt;- queen_weights(guerry) crm_prp &lt;- as.numeric(as.character(guerry_sp$Crm_prp)) Why are we using as.numeric(as.character(guerry_sp\\(Crm_prp))&lt;/code&gt;?&lt;/p&gt; &lt;p&gt;As we can see from the output of &lt;code&gt;readOGR(guerry_path)&lt;/code&gt; that: _“Integer64 fields read as strings: dept Crm_prs Crm_prp Litercy Donatns Infants Suicids MainCty_”, so &lt;code&gt;guerry_sp\\)Crm_prp is with data type factor, so as.numeric(as.character()) is used to convert it to a column with numeric values without lossing precisions. 7.3.1 Local Moran Map lisa &lt;- local_moran(queen_w, crm_prp) Now, with the LISA results, we can do exploratory spatial data analysis by generating a LISA cluster map: lisa_colors &lt;- lisa$GetColors() lisa_labels &lt;- lisa$GetLabels() lisa_clusters &lt;- lisa$GetClusterIndicators() plot(guerry_sp, col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}), border = &quot;#333333&quot;, lwd=0.2) title(main = &quot;Local Moran Map of Crm_prp&quot;) legend(&#39;bottomleft&#39;, legend = lisa_labels, fill = lisa_colors, border = &quot;#eeeeee&quot;) From the above code, you can see that we still use sp object to do plotting. The values of cluster indicators from rgeoda’s LISA object are used to make the LISA map.This emphasis that rgeoda is a API focused library, which only provides the core functions of spatial data analysis for easy integration. You can easily append the lisa results to original sp object by manipulating the data.frame object inside the sp object. guerry_sp$moran_cluster &lt;- lisa_clusters If you check the values of the cluster indicators, you will see they are integer numbers 0 (not significant), 1 (high-high cluster), 2 (low-low cluster), 3 (low-high cluster), 4 (high-low cluster), 5 (neighborless/island), 6 (undefined), which are excatly the same with GeoDa software when you save LISA results to a table: lisa_clusters ## [1] 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 0 0 2 2 0 0 0 0 0 0 0 0 0 ## [36] 1 0 0 0 1 1 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 2 2 0 0 1 0 0 0 0 0 3 0 0 0 ## [71] 2 0 2 2 0 2 0 0 0 0 0 0 3 0 0 To create a siginificant map that is associated with the Local Moran map: lisa_p &lt;- lisa$GetPValues() p_labels &lt;- c(&quot;Not significant&quot;, &quot;p &lt;= 0.05&quot;, &quot;p &lt;= 0.01&quot;, &quot;p &lt;= 0.001&quot;) p_colors &lt;- c(&quot;#eeeeee&quot;, &quot;#84f576&quot;, &quot;#53c53c&quot;, &quot;#348124&quot;) plot(guerry_sp, col=sapply(lisa_p, function(x){ if (x &lt;= 0.001) return(p_colors[2]) else if (x &lt;= 0.01) return(p_colors[3]) else if (x &lt;= 0.05) return (p_colors[4]) else return(p_colors[1]) }), border = &quot;#333333&quot;, lwd=0.2) title(main = &quot;Local Moran Map of Crm_prp&quot;) legend(&#39;bottomleft&#39;, legend = p_labels, fill = p_colors, border = &quot;#eeeeee&quot;) 7.3.2 Local Geary Map Another example is to create a map of local Geary: lisa &lt;- local_geary(queen_w, crm_prp) lisa_colors &lt;- lisa$GetColors() lisa_labels &lt;- lisa$GetLabels() lisa_clusters &lt;- lisa$GetClusterIndicators() plot(guerry_sp, col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}), border = &quot;#333333&quot;, lwd=0.2) title(main = &quot;Local Geary Map of Crm_prp&quot;) legend(&#39;bottomleft&#39;, legend = lisa_labels, fill = lisa_colors, border = &quot;#eeeeee&quot;) 7.3.3 Local G Map To create a map of local G: lisa &lt;- local_g(queen_w, crm_prp) lisa_colors &lt;- lisa$GetColors() lisa_labels &lt;- lisa$GetLabels() lisa_clusters &lt;- lisa$GetClusterIndicators() plot(guerry_sp, col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}), border = &quot;#333333&quot;, lwd=0.2) title(main = &quot;Local Getis-Ord&#39;s G Map of Crm_prp&quot;) legend(&#39;bottomleft&#39;, legend = lisa_labels, fill = lisa_colors, border = &quot;#eeeeee&quot;) 7.3.4 SKATER Map To create a map of SKATER clustering map: Crm_prs &lt;- as.numeric(as.character(guerry_sp$Crm_prs)) Litercy &lt;- as.numeric(as.character(guerry_sp$Litercy)) Donatns &lt;- as.numeric(as.character(guerry_sp$Donatns)) Infants &lt;- as.numeric(as.character(guerry_sp$Infants)) Suicids &lt;- as.numeric(as.character(guerry_sp$Suicids)) data &lt;- list(Crm_prs, crm_prp, Litercy, Donatns, Infants, Suicids) guerry_clusters &lt;- skater(4, queen_w, data) # Get some colors for each clusters skater_colors &lt;- palette()[2:5] skater_labels &lt;- c(&quot;c1&quot;,&quot;c2&quot;,&quot;c3&quot;,&quot;c4&quot;) # Assign a color for each observation colors &lt;- rep(&quot;#000000&quot;, queen_w$num_obs) for (i in 1:4) { for (j in guerry_clusters[i]) { colors[j+1] &lt;- skater_colors[i] } } # plot plot(guerry_sp, col=colors, border = &quot;#333333&quot;, lwd=0.2) title(main = &quot;SKATER Clustering Map&quot;) legend(&#39;bottomleft&#39;, legend = skater_labels, fill = skater_colors, border = &quot;#eeeeee&quot;) Why are we using as.numeric(as.character(guerry_sp$Crm_prp)) here to get values from data.frame? As we can see from the output of readOGR(guerry_path) that: _&quot;Integer64 fields read as strings: dept Crm_prs Crm_prp Litercy Donatns Infants Suicids MainCty_&quot; , that means guerry_sp$Crm_prp is with data type factor, so as.numeric(as.character()) is used to convert it to a column with numeric values without lossing precisions. 7.3.5 Max-p Clustering Map bound_vals &lt;- as.numeric(guerry_sp$Pop1831) min_bound &lt;- 3236.67 # 10% of Pop1831 maxp_clusters &lt;- maxp(queen_w, data, bound_vals, min_bound, &quot;greedy&quot;) # Get some colors for each clusters maxp_colors &lt;- palette()[2:10] maxp_labels &lt;- c(&quot;c1&quot;,&quot;c2&quot;,&quot;c3&quot;,&quot;c4&quot;,&quot;c5&quot;,&quot;c6&quot;,&quot;c7&quot;,&quot;c8&quot;) # Assign a color for each observation colors &lt;- rep(&quot;#000000&quot;, queen_w$num_obs) for (i in 1:8) { for (j in maxp_clusters[i]) { colors[j+1] &lt;- maxp_colors[i] } } # plot plot(guerry_sp, col=colors, border = &quot;#333333&quot;, lwd=0.2) title(main = &quot;Max-p Clustering Map&quot;) legend(&#39;bottomleft&#39;, legend = maxp_labels, fill = maxp_colors, border = &quot;#eeeeee&quot;) "],
["esda-with-rgeoda-and-sf.html", "8 ESDA with rgeoda and sf 8.1 Start from sf package 8.2 Create geoda object from sf 8.3 ESDA with rgeoda and sf", " 8 ESDA with rgeoda and sf Another modern and popular routine for spatial data analysis with R is to use sf library to process geospatial dataset, analyze spatial data and plot the results on maps. rgeoda provides utility functions to create a geoda instance from an sf object, so that users can easily integrate the functions of spatial data analysis in rgeoda into their existing work. In this note, we will work with sf and rgeoda libraries to do exploratory spatial data analysis (ESDA). 8.1 Start from sf package The sf package has been popular tool to handle geospatial data. It is a good substitue of sp package which will be deprecated soon. For example, to load a geospatial data (e.g. a ESRI Shapefile) using sf: # use the Guerry.shp comes with the rgeoda package guerry_path &lt;- system.file(&quot;extdata&quot;, &quot;Guerry.shp&quot;, package = &quot;rgeoda&quot;) # load sf library library(sf) ## Linking to GEOS 3.7.2, GDAL 2.4.1, PROJ 6.1.0 Note: to install sf library in R, you can run: install.packages(‘sf’) Then, we can call st_read() function to read Guerry.shp file and this function will returns an sf object guerry_sf &lt;- st_read(guerry_path) ## Reading layer `Guerry&#39; from data source `/usr/local/lib/R/3.6/site-library/rgeoda/extdata/Guerry.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 85 features and 26 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 47680 ymin: 1703258 xmax: 1031401 ymax: 2677441 ## epsg (SRID): 27572 ## proj4string: +proj=lcc +lat_1=46.8 +lat_0=46.8 +lon_0=0 +k_0=0.99987742 +x_0=600000 +y_0=2200000 +a=6378249.2 +b=6356515 +towgs84=-168,-60,320,0,0,0,0 +pm=paris +units=m +no_defs You can simply call plot() function to render the first 9 chorepleth maps using the frist 9 variables in the dataset: plot(guerry_sf) ## Warning: plotting the first 9 out of 26 attributes; use max.plot = 26 to ## plot all 8.2 Create geoda object from sf sf package makes it easy to work with geospatial data. It also provides functions to do basic spatial data analysis. rgeoda provides helper function sf_to_geoda to create a geoda object from a sf object. Users can then call rgeoda functions to do further spatial data analysis. Create a geoda object from the sf object guerry_sp you just created. # load rgeoda library library(rgeoda) # call function to create a geoda object from sf object guerry &lt;- sf_to_geoda(guerry_sf) rgeoda uses wkb, which is a binary representation of geometries, to exchange data between sf and libgeoda in memory. By default, sf_to_geoda() only using geometries to create a geoda object, which is fast and user can reuse the data.frame from the sf object to do analysis. This function has an optional parameter with_table, to allow user to use both geometries and data.frame to create a geoda object by calling, for example: sp_to_geoda(guerry_sp, with_table=TRUE) 8.3 ESDA with rgeoda and sf Now, with the geoda object guerry, you can call rgeoda’s spatial analysis functions. For example, to examine the local Moran statistics of variable “crm_prp” (Population per Crime against persons): queen_w &lt;- queen_weights(guerry) crm_prp &lt;- as.numeric(guerry_sf$Crm_prp) queen_w ## Reference class object of class &quot;Weight&quot; ## Field &quot;gda_w&quot;: ## An object of class &quot;_p_GeoDaWeight&quot; ## Slot &quot;ref&quot;: ## &lt;pointer: 0x7f99377273a0&gt; ## ## Field &quot;is_symmetric&quot;: ## [1] TRUE ## Field &quot;sparsity&quot;: ## [1] 0 ## Field &quot;density&quot;: ## [1] 5.813149 ## Field &quot;min_neighbors&quot;: ## [1] 2 ## Field &quot;max_neighbors&quot;: ## [1] 8 ## Field &quot;num_obs&quot;: ## [1] 85 ## Field &quot;mean_neighbors&quot;: ## [1] 4.941176 ## Field &quot;median_neighbors&quot;: ## [1] 5 crm_prp ## [1] 15890 5521 7925 7289 8174 10263 8847 9597 4086 10431 6731 ## [12] 5291 4500 11645 13018 5357 10503 12949 9159 7050 20235 10237 ## [23] 5914 7759 4774 4016 6842 7990 7204 10486 7423 10954 6524 ## [34] 7624 6909 8326 8059 6170 6017 12665 18043 9392 5042 9049 ## [45] 8943 5990 8520 7424 4950 9539 9198 6831 9190 7940 4529 ## [56] 8236 6175 6659 8248 4040 12141 8533 9797 7632 4920 4915 ## [67] 4504 7770 10708 8294 1368 2906 5786 3879 6863 7144 6241 ## [78] 8680 9572 5731 7566 4710 6402 9044 6516 8.3.1 Local Moran Map lisa &lt;- local_moran(queen_w, crm_prp) Now, with the LISA results, we can do exploratory spatial data analysis by generating a LISA cluster map: lisa_colors &lt;- lisa$GetColors() lisa_labels &lt;- lisa$GetLabels() lisa_clusters &lt;- lisa$GetClusterIndicators() plot(st_geometry(guerry_sf), col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}), border = &quot;#333333&quot;, lwd=0.2) title(main = &quot;Local Moran Map of Crm_prp&quot;) legend(&#39;bottomleft&#39;, legend = lisa_labels, fill = lisa_colors, border = &quot;#eeeeee&quot;) From the above code, you can see that we still use sp object to do plotting. The values of cluster indicators from rgeoda’s LISA object are used to make the LISA map.This emphasis that rgeoda is a API focused library, which only provides the core functions of spatial data analysis for easy integration. You can easily append the lisa results to original sp object by manipulating the data.frame object inside the sp object. guerry_sf$moran_cluster &lt;- lisa_clusters If you check the values of the cluster indicators, you will see they are integer numbers 0 (not significant), 1 (high-high cluster), 2 (low-low cluster), 3 (low-high cluster), 4 (high-low cluster), 5 (neighborless/island), 6 (undefined), which are excatly the same with GeoDa software when you save LISA results to a table: lisa_clusters ## [1] 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 0 0 0 2 2 0 0 0 0 0 0 0 0 0 ## [36] 1 0 0 0 1 1 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 2 2 0 0 1 0 0 0 0 0 3 0 0 0 ## [71] 2 0 2 2 0 2 0 0 0 0 0 0 3 0 0 To create a siginificant map that is associated with the Local Moran map: lisa_p &lt;- lisa$GetPValues() p_labels &lt;- c(&quot;Not significant&quot;, &quot;p &lt;= 0.05&quot;, &quot;p &lt;= 0.01&quot;, &quot;p &lt;= 0.001&quot;) p_colors &lt;- c(&quot;#eeeeee&quot;, &quot;#84f576&quot;, &quot;#53c53c&quot;, &quot;#348124&quot;) plot(st_geometry(guerry_sf), col=sapply(lisa_p, function(x){ if (x &lt;= 0.001) return(p_colors[4]) else if (x &lt;= 0.01) return(p_colors[3]) else if (x &lt;= 0.05) return (p_colors[2]) else return(p_colors[1]) }), border = &quot;#333333&quot;, lwd=0.2) title(main = &quot;Local Moran Map of Crm_prp&quot;) legend(&#39;bottomleft&#39;, legend = p_labels, fill = p_colors, border = &quot;#eeeeee&quot;) 8.3.2 Local Geary Map Another example is to create a map of local Geary: lisa &lt;- local_geary(queen_w, crm_prp) lisa_colors &lt;- lisa$GetColors() lisa_labels &lt;- lisa$GetLabels() lisa_clusters &lt;- lisa$GetClusterIndicators() plot(st_geometry(guerry_sf), col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}), border = &quot;#333333&quot;, lwd=0.2) title(main = &quot;Local Geary Map of Crm_prp&quot;) legend(&#39;bottomleft&#39;, legend = lisa_labels, fill = lisa_colors, border = &quot;#eeeeee&quot;) 8.3.3 Local G Map To create a map of local G: lisa &lt;- local_g(queen_w, crm_prp) lisa_colors &lt;- lisa$GetColors() lisa_labels &lt;- lisa$GetLabels() lisa_clusters &lt;- lisa$GetClusterIndicators() plot(st_geometry(guerry_sf), col=sapply(lisa_clusters, function(x){return(lisa_colors[[x+1]])}), border = &quot;#333333&quot;, lwd=0.2) title(main = &quot;Local Getis-Ord&#39;s G Map of Crm_prp&quot;) legend(&#39;bottomleft&#39;, legend = lisa_labels, fill = lisa_colors, border = &quot;#eeeeee&quot;) 8.3.4 SKATER Map To create a map of SKATER clustering map: Crm_prs &lt;- as.numeric(guerry_sf$Crm_prs) Litercy &lt;- as.numeric(guerry_sf$Litercy) Donatns &lt;- as.numeric(guerry_sf$Donatns) Infants &lt;- as.numeric(guerry_sf$Infants) Suicids &lt;- as.numeric(guerry_sf$Suicids) data &lt;- list(Crm_prs, crm_prp, Litercy, Donatns, Infants, Suicids) guerry_clusters &lt;- skater(4, queen_w, data) # Get some colors for each clusters skater_colors &lt;- palette()[2:5] skater_labels &lt;- c(&quot;c1&quot;,&quot;c2&quot;,&quot;c3&quot;,&quot;c4&quot;) # Assign a color for each observation colors &lt;- rep(&quot;#000000&quot;, queen_w$num_obs) for (i in 1:4) { for (j in guerry_clusters[i]) { colors[j+1] &lt;- skater_colors[i] } } # plot plot(st_geometry(guerry_sf), col=colors, border = &quot;#333333&quot;, lwd=0.2) title(main = &quot;SKATER Clustering Map&quot;) legend(&#39;bottomleft&#39;, legend = skater_labels, fill = skater_colors, border = &quot;#eeeeee&quot;) 8.3.5 Max-p Clustering Map bound_vals &lt;- as.numeric(guerry_sf$Pop1831) min_bound &lt;- 3236.67 # 10% of Pop1831 maxp_clusters &lt;- maxp(queen_w, data, bound_vals, min_bound, &quot;greedy&quot;) # Get some colors for each clusters maxp_colors &lt;- palette()[2:10] maxp_labels &lt;- c(&quot;c1&quot;,&quot;c2&quot;,&quot;c3&quot;,&quot;c4&quot;,&quot;c5&quot;,&quot;c6&quot;,&quot;c7&quot;,&quot;c8&quot;) # Assign a color for each observation colors &lt;- rep(&quot;#000000&quot;, queen_w$num_obs) for (i in 1:8) { for (j in maxp_clusters[i]) { colors[j+1] &lt;- maxp_colors[i] } } # plot plot(st_geometry(guerry_sf), col=colors, border = &quot;#333333&quot;, lwd=0.2) title(main = &quot;Max-p Clustering Map&quot;) legend(&#39;bottomleft&#39;, legend = maxp_labels, fill = maxp_colors, border = &quot;#eeeeee&quot;) "]
]
